я вот подумал, а нету такого алгоритма где использутеся алгорит открытой адресации, но есть отличие от классической реализации. В случае коллизии, мы не сразу идем искать свободную соседнюю ячейка а пытамся вычислить индекс от второй хеш функции, и так может продолжаться до n попыток, если все n попыток вычисления хеша дали коллизию, мы просто работает по алгоритму линейного пробирования(например). Такие алгоритмы построения и поддержания хеш-таблиц есть?




**Да, конечно! Вы практически точно описали классический и очень распространенный метод, который называется **Двойное хеширование (Double Hashing)**.****

Это именно тот алгоритм, который использует вторую хеш-функцию для разрешения коллизий, и в худшем случае откатывается к линейному сканированию (или другому fallback).

### Двойное хеширование (Double Hashing)

Это метод закрытого хеширования (open addressing), где для разрешения коллизий используется не одна, а две хеш-функции.

**Как работает алгоритм поиска и вставки:**

1.  **Первая попытка:** Вычисляется исходный индекс с помощью основной хеш-функции:
    `index = h1(key) % table_size`

2.  **Если ячейка `[index]` свободна или содержит нужный ключ:** операция на этом завершается (вставка или найден).

3.  **Если произошла коллизия:** Вступает в дело **вторая хеш-функция `h2(key)`**. Она вычисляет **шаг probing**.
    *   Шаг должен быть ненулевым и желательно взаимно простым с размером таблицы, чтобы проверить все ячейки.
    *   Новый индекс вычисляется по формуле:
        `index = (index + h2(key)) % table_size`
    *   Или в общем виде для `i`-ой попытки:
        `index_i = (h1(key) + i * h2(key)) % table_size`

4.  **Процесс повторяется** (п. 2-3), пока не найдется свободная ячейка (для вставки) или искомый ключ.

5.  **Fallback (на худой конец):** На практике вторая функция `h2` проектируется так, чтобы избежать бесконечных циклов. Но если по какой-то причине шаг `h2(key)` оказался плохим (например, равен 0 или кратен размеру таблицы), реализация *должна* иметь fallback. Чаще всего это **увеличение шага на 1** (фактически, переход к линейному пробированию) или использование заранее подготовленной константы. Вы были правы, предполагая это.

---

### Сравнение с другими методами открытой адресации

| Метод                 | Формула для `i`-ой попытки                          | Проблема                             |
| --------------------- | --------------------------------------------------- | ------------------------------------ |
| **Линейное пробирование**  | `(h1(key) + i) % table_size`                        | Кластеризация (образование слипшихся регионов) |
| **Квадратичное пробирование** | `(h1(key) + c1*i + c2*i²) % table_size`             | Вторичная кластеризация              |
| **Двойное хеширование**    | `(h1(key) + i * h2(key)) % table_size`              | **Наиболее близко к идеальной случайности.** Разные клюцы имеют разный шаг probing, что minimizes кластеризацию. |

### Ключевые особенности и преимущества Двойного хеширования:

*   **Золотой стандарт** открытой адресации. Считается одним из лучших методов из-за того, что он лучше всего имитирует равномерное случайное распределение при probing'e.
*   **Требует всего O(1) дополнительной памяти** (в отличие от двухуровневого perfect hashing, которому нужно хранить кучу параметров для подтаблиц). Нужно хранить только две хеш-функции.
*   **Поддерживает динамические операции** (вставку, удаление, поиск) без необходимости полной перестройки таблицы при каждом изменении, в отличие от perfect hashing.
*   **Не гарантирует отсутствия коллизий** и в худшем случае может деградировать до O(n), но на практике при хороших функциях и невысоком коэффициенте заполнения работает очень хорошо.

### Итог

Вы интуитивно пришли к описанию одного из самых эффективных и популярных алгоритмов — **Двойного хеширования**. Ваше предположение о fallback к линейному пробированию также верно для надежных реализаций.

**Таким образом, perfect hashing и двойное хеширование — это два решения с разным компромиссом:**
*   **Perfect Hashing:** Максимальная скорость (O(1) гарантировано), но только для статических данных. **Плата за скорость — отсутствие гибкости.**
*   **Двойное хеширование:** Очень высокая скорость на практике (близкая к O(1)), поддержка динамических данных. **Плата за гибкость — отсутствие строгой гарантии и потенциальная деградация.**
* 