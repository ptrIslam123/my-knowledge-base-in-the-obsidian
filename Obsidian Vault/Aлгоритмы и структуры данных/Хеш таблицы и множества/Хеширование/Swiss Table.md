
**Swiss Table — это реализация хеш-таблицы с открытой адресацией, которая использует метаданные для управления коллизиями. Она была представлена в библиотеке Abseil (C++) и показывает выдающуюся производительность.**

Как и прежде, данные хранятся в едином массиве. Однако теперь массив разбивается на логические группы по 8 слотов (возможны и более крупные размеры групп в зависимости от доступных SIMD инструкции на машине). 

Каждая группа сопровождается 64-битным(или 8-байтовым) управляющим словом (control word), которое содержит метаданные:

- Каждый из восьми байт управляющего слова соответствует одному из 8 слотов в группе.
- Значение каждого байта указывает, является ли слот пустым, удалённым или занятым.
- Если он используется, байт содержит 7 младших бит хеша для ключа этого слота (так называемого h2).

Отлично! Давайте глубоко разберём структуру **control word** (управляющего слова) в Swiss Table — это действительно сердце всей магии производительности.

## Базовая структура каждого Control Word

**Control Word** — это 64-битное слово, разделённое на 8 байт (по 8 бит каждый), где каждый байт соответствует одному слоту в группе:

```
MSB                                                                   LSB
╔════════╤════════╤════════╤════════╤════════╤════════╤════════╤════════╗
║ Byte 7 │ Byte 6 │ Byte 5 │ Byte 4 │ Byte 3 │ Byte 2 │ Byte 1 │ Byte 0 ║
║  (0x)  │  (0x)  │  (0x)  │  (0x)  │  (0x)  │  (0x)  │  (0x)  │  (0x)  ║
╚════════╧════════╧════════╧════════╧════════╧════════╧════════╧════════╝
   │        │        │        │        │        │        │        │
   ▼        ▼        ▼        ▼        ▼        ▼        ▼        ▼
 Slot 7   Slot 6   Slot 5   Slot 4   Slot 3   Slot 2   Slot 1   Slot 0
```

## Детальное устройство одного Control Byte

Каждый байт (8 бит) имеет следующую структуру:

```
MSB       LSB
╔═╤═╤═╤═╤═╤═╤═╤═╗
║7│6│5│4│3│2│1│0║
╚═╧═╧═╧═╧═╧═╧═╧═╝
 │ └───┬─────┘ │
 │     │       │
 │     │       └── Бит занятости (Occupancy)
 │     │           • 1 = слот занят
 │     │           • 0 = слот пуст/удалён
 │     │
 │     └── 7-битный хеш H2 (содержит младшие 7 бит от полного хеша ключа)
 │
 └── Всегда 1 для занятых ячеек (для оптимизации поиска)
```

## Возможные значения Control Byte

### 1. **Пустой слот** (Empty)
```
╔═╤═╤═╤═╤═╤═╤═╤═╗
║0│0│0│0│0│0│0│0║ → 0x00
╚═╧═╧═╧═╧═╧═╧═╧═╝
```
- Все биты = 0
- Слот никогда не использовался
- Поиск останавливается при встрече такого слота

### 2. **Удалённый слот** (Tombstone)
```
╔═╤═╤═╤═╤═╤═╤═╤═╗
║0│0│0│0│0│0│0│1║ → 0x01
╚═╧═╧═╧═╧═╧═╧═╧═╝
  ↑
  Бит занятости = 1, но H2 = 0
```
- Ключ был удалён
- Не прерывает поиск (нужно продолжать пробирование)
- Может быть переиспользован при вставке

### 3. **Занятый слот** (Occupied)
```
╔═╤═╤═╤═╤═╤═╤═╤═╗
║1│0│1│1│0│0│1│0║ → 0xB2
╚═╧═╧═╧═╧═╧═╧═╧═╝
  │   └───┬───┘
  │       └── H2 = 0x32 (50 в decimal)
  │
  └── Старший бит = 1 (признак занятости)
```

---

## Обьяснение зачем хранить младшие 7 бит от полного хеша ключа в control byte

Допустим, мы хотим проверить группу на наличие нужного ключа. Если бы мы не хранили в **control byte** (в 7 младших битах) хеш искомого ключа, нам пришлось бы просто пройтись в цикле по всем слотам группы и сравнивать ключи напрямую.

Однако, если в **control byte** мы храним 7 младших битов хеша ключа, то с помощью одной SIMD-инструкции мы можем одновременно проверить, совпадают ли эти 7 битов у какого-либо слота в группе с нашими 7 битами из control byte.

Что мы получаем в результате:
- Если сравнение даёт **отрицательный результат**, мы точно знаем, что ни один из слотов данной группы не содержит искомый ключ. Это позволяет быстро исключить группу из рассмотрения.
- Если же результат **положительный**, существует высокая вероятность (но не гарантия), что в группе находится нужный ключ — ведь совпали только 7 младших битов хеша, а оставшиеся 53 бита могут отличаться. В таком случае мы переходим к точной проверке: итерируемся по слотам группы и сравниваем ключи полностью.

Такой подход может приводить к **ложноположительным срабатываниям(false positives - вероятность коллизии для 7-битного хеша — 1/128, что довольно мало)**, когда совпадение по 7 битам есть, но сам ключ отсутствует. Однако это компенсируется значительным ускорением поиска за счёт быстрого отсева заведомо неподходящих групп.

Эта операция очень мощная, так как мы фактически выполняем 8 шагов последовательного поиска одновременно, в параллельном режиме. Это ускоряет поиск и вставку, уменьшая среднее число необходимых сравнений.

### Примерный код поиска без хранения младших 7 бит от полного хеша ключа
```c++
for (const auto& slot : group.slots) {
	if (slot.state == SlotState::Empty) {
		break;  // Дальше нет смысла искать — цепочка прервана
	} else if (slot.state == SlotState::Occupied) {
        if (slot.key == key) {
            return true;  // Ключ найден
        }
    } else if (slot.state == SlotState::Deleted) {
	    // просто пропускаем/продолжаем
    }
}
return false;  // Не найден в этой группе
```

### Примерный код поиска c использованием младших 7 бит от полного хеша ключа
```c++
// Предполагаем, что:
// - hash — полный хеш ключа
// - group.control — массив из 8 uint8_t (control bytes)
// - group.slots — массив из 8 слотов
// - Мы используем SSE2 (широко доступно)

bool FindInGroup(const Group& group, size_t hash, const Key& key) {
    uint8_t probe = hash & 0x7F;  // 7 младших бит хеша

    // Загружаем control bytes группы в SIMD-регистр (128 бит)
    __m128i control_vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(group.control));

    // Создаём маску: 8 копий значения 'probe'
    __m128i probe_vec = _mm_set1_epi8(probe);

    // Сравниваем: где control == probe?
    __m128i cmp_result = _mm_cmpeq_epi8(control_vec, probe_vec);

    // Преобразуем результат сравнения в битовую маску (8 бит)
    int mask = _mm_movemask_epi8(cmp_result);  // Получаем 8-битную маску

    // Если маска == 0 — совпадений нет, ключа в группе точно нет
    if (mask == 0) {
        return false;
    }

    // Теперь проверяем только те слоты, где был бит в маске
    for (int i = 0; i < 8; ++i) {
        if (mask & (1 << i)) {
            const auto& slot = group.slots[i];
            // Убедимся, что слот занят (защита от deleted/empty)
            if (slot.state == SlotState::Occupied &&
                slot.key == key) {
                return true;  // Ключ найден
            }
        }
    }

    return false;  // Совпали 7 бит, но ключ не тот (ложноположительное срабатывание)
}
```
