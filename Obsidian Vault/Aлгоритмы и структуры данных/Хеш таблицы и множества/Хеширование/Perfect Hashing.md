**Perfect Hashing (Совершенное хеширование)** — это метод построения **хеш-таблицы для статического набора ключей**, который гарантирует **отсутствие коллизий** и, как следствие, время поиска **O(1) в худшем случае**.

*   **Статический набор:** Ключи известны заранее и не изменяются. Добавление нового ключа требует полного перестроения всей структуры.
*   **Цель:** Максимальная скорость поиска. Идеально для ключевых слов языков программирования, зарезервированных идентификаторов, DNS-записей в кеше — любых данных, которые загружаются один раз и потом часто читаются и редко изменяются(insert, delete).

---

### Архитектура: Двухуровневая схема

Основной эффективный метод — использование двухуровневой хеш-таблицы, часто называемой методом Чи-Чжоу (Jieni Czhu).

#### Уровень 1: Главная (Первичная) таблица

*   Представляет собой массив из `m` ячеек (бакетов). Размер `m` обычно выбирается близким к количеству ключей `n` (`m ≈ n`).
*   Каждая ячейка первого уровня не хранит данные напрямую. Вместо этого она содержит:
    *   **Указатель** на вторичную хеш-таблицу или же она сама является втроичной хеш-таблицей(многоуровневый массив).
    *   **Параметры** для своей хеш-функции второго уровня (например, случайные числа для универсального хеширования).
*   Для распределения ключей по этим бакетам используется **первая хеш-функция** `h(key)` для первого уровня она хеш функция одна. Её выбор не критичен, она может вызывать коллизии. Часто её выбирают из универсального семейства хеш-функций.

### Важно:
Чаще всего реализуется подтаблица(побакеты) именно через массив указателей на отдельно алоцированные подтаблицы. Прямое включение подтаблицы в ячейку первого уровня встречается реже, так как размеры подтаблиц разные, и это усложняет управление памятью. Ваша формулировка верна, но на практике первый вариант (указатель) — доминирующий.

#### Уровень 2: Вторичные (Подчиненные) таблицы

*   Для каждого бакета `i` первого уровня существует **своя собственная** маленькая хеш-таблица.
*   **Размер** этой таблицы `m_i` вычисляется по формуле: **`m_i = (n_i)^2`**, где `n_i` — количество ключей, попавших в бакет `i` согласно функции `h(key)`.
    *   *Почему квадрат?* Это ключевой момент. Квадратичный размер гарантирует высокую вероятность (более 50%) подобрать функцию без коллизий. На практике это означает, что подбор происходит за несколько попыток.
*   Для каждой вторичной таблицы **подбирается своя уникальная хеш-функция** `h_i(key)`. Процесс подбора: мы перебираем параметры функции (например, меняем seed для вычисления), пока все `n_i` ключей не займут `n_i` уникальных ячеек в таблице размером `(n_i)^2` **без единой коллизии**.
*   Именно в этих ячейках второго уровня и хранятся конечные данные (или указатели на них).


### Важно:
Немного технических деталей о том, _как_ именно подбираются функции:

- **Семейство функций:** Обычно используется универсальное семейство хеш-функций. Классический выбор для второго уровня — семейство функций вида:  
    `h_{a, b}(k) = ((a * k + b) mod p) mod m_i`  
    где `p` — большое простое число, большее любого возможного ключа, а `a` и `b` — случайные параметры из диапазона `[1, p-1]` и `[0, p-1]` соответственно. Подбор функции заключается в переборе пар `(a, b)` до тех пор, пока не найдется такая, что нет коллизий.
    
- **Оптимизация для пустых бакетов:** Для бакетов, где `n_i = 0`, таблицу второго уровня не создают, а в ячейке первого уровня хранят `nullptr` или специальный флаг. Это экономит память.
    
- **Оптимизация для маленьких бакетов:** Если в бакете ровно один ключ (`n_i = 1`), то размер таблицы можно сделать равным 1 (`m_i = 1`). Функцию `h_i` для такого бакета можно выбрать любую (например, всегда возвращающую 0), так как коллизий быть не может по определению.

---

### Алгоритм построения (Создание таблицы)
### 1. Фаза Построения (Инициализация, "Медленная фаза")

Это предварительный, возможно, вычислительно дорогой этап, который происходит **один раз** перед началом использования таблицы.

**Что на этом этапе происходит:**

*   **Ввод данных:** Вы передаете алгоритму весь ваш **статический набор ключей** (и, возможно, связанных с ними значений).
*   Алгоритм начинает свою работу:
    1.  Он берет первую хеш-функцию `H` (уровень 1) и смотрит, как она распределяет все ключи по бакетам.
    2.  Если распределение слишком неравномерное (один бакет переполнен), он может случайным образом выбрать *другую* функцию `H` и попробовать снова, чтобы добиться более сбалансированного распределения.
    3.  Для **каждого** непустого бакета `i` алгоритм начинает перебор: он пробует разные параметры (например, разные случайные числа-"семена") для функции второго уровня `H_i`, пока не найдет такую, которая **равномерно распределяет ключи именно этого бакета по его личной таблице размером `(n_i)^2` без единой коллизии**.
*   **Результат фазы:** По окончанию этого процесса у нас есть:
    *   **Готовая к работе структура данных** в памяти.
    *   **Подобранные и зафиксированные параметры** для всех хеш-функций: одна главная `H` и по одной `H_i` для каждого непустого бакета.

Этот этап может быть небыстрым, но он выполняется всего один раз, обычно на этапе запуска программы или загрузки данных.

### 2. Фаза Поиска (Работа, "Быстрая фаза")

**Только после полного завершения фазы построения** таблица готова к использованию.

**Теперь, когда таблица инициализирована:**

*   Все ключи уже лежат на своих местах.
*   Все хеш-функции (`H`, `H_0`, `H_1`, ..., `H_m`) уже выбраны и настроены именно так, чтобы гарантировать отсутствие коллизий для *этого конкретного* набора ключей.
*   Любой запрос на поиск просто **вычисляет два хеша** по уже готовым формулам и совершает **два обращения к памяти** (по индексу первого уровня, затем по индексу второго уровня). Это детерминированные, константные операции.

---
### Алгоритм поиска

Поиск элемента по ключу `k` происходит за **две строго константные операции**:

1.  **Вычисление индекса первого уровня:**
    *   `i = h(k) % m`
2.  **Обращение ко второму уровню:**
    *   Из главной таблицы берем параметры функции `h_i` для бакета `i`.
    *   `j = h_i(k) % m_i`
3.  **Извлечение результата:**
    *   Обращаемся к вторичной таблице по адресу `[i][j]`.
    *   Если ключ в этой ячейке совпадает с `k` — возвращаем значение.
    *   Если ячейка пуста или ключ не совпадает — искомого ключа `k` в таблице нет. (Поскольку коллизий нет, другой ключ в этой ячейке оказаться не может).

**Время поиска: O(1) в худшем случае.**

---

## Алгоритм вставки и удаления

Это **полное перестроение (rebuild)**. Это не просто "добавить ключ в существующую структуру". Алгоритм должен:

1. Взять весь _старый_ набор ключей.
2. Добавить новый ключ (или удалить старый).
3. **Полностью заново** выполнить всю **Фазу Построения**: заново выбрать `H` (возможно, другую), заново распределить ключи по бакетам, заново подобрать _все_ функции `H_i` для _всех_ бакетов и заново разместить _все_ данные в памяти.

Это очень дорогая операция, стоимостью `O(n)`, что и является главным ограничением метода.
### Почему это работает? (Математическое обоснование)

*   **Отсутствие коллизий:** Достигается за счет того, что для каждой группы ключей, имевших коллизию на первом уровне, мы решили проблему "в лоб", подобрав свою идеальную функцию.
*   **Эффективность по памяти:** Казалось бы, суммарный размер памяти `Σ (n_i)^2` должен быть огромным. Однако можно доказать, что **математическое ожидание** этой суммы меньше `2n`.
    *   Это следует из того, что вероятность для ключа попасть в какой-либо бакет равна `1/m`. При `m = n` математическое ожидание количества коллизий и размеров бакетов оказывается таким, что сумма квадратов линейна по `n`.
    *   Таким образом, вся структура в среднем consumes **O(n)** памяти.

---

### Плюсы и минусы

| Плюсы                                                                 | Минусы                                                                                                                              |
| --------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| ✅ **Гарантированное время поиска O(1)** в худшем случае.             | ❌ **Только для статических данных.** Любое изменение набора ключей требует полного перестроения всей структуры.                    |
| ✅ **Предсказуемая производительность.** Скорость не деградирует.     | ❌ **Сложность и время построения.** Требуется распределять ключи и для каждого бакета подбирать свою хеш-функцию.                 |
| ✅ **Эффективность.** Память расходуется линейно от числа ключей (O(n)). | ❌ **Необходимость хранить параметры** множества хеш-функций.                                                                      |

---

### Где применяется?

*   **Компиляторы и интерпретаторы:** Для быстрой проверки, является ли слово ключевым (например, `if`, `while`, `return`).
*   **Базы данных:** Для хранения зарезервированных слов SQL или метаинформации.
*   **Кеширующие сетевые устройства (DNS-серверы, роутеры):** Для хранения статических таблиц маршрутизации или преобразования адресов.
*   **Любой код, где требуется сверхбыстрый поиск по неизменяемому словарю.**