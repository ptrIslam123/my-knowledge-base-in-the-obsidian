**Хеш-таблица** (hash table) — это структура данных, которая реализует абстрактный тип данных "ассоциативный массив" (словарь). Она позволяет хранить пары "ключ-значение" и обеспечивает эффективные операции:
- Вставки (`insert`)
- Поиска (`get`) 
- Удаления (`delete`)

## Важно:
* ***Неизменяемые ключи**: Ключи должны быть immutable(не изменяемые)
* **Проблемы с памятью**: Может потреблять больше памяти чем массивы
* **Порядок элементов**: Не гарантирует порядок элементов (в базовой реализации)
* **Зависимость от хеш-функции**: Качество напрямую влияет на производительность
* Любой поиск в хеш‑таблице (как с открытым, так и с закрытым хешированием) должен выбрать начальную позицию для своей последовательности пробирования на основе хеша запрашиваемого ключа. Преобразование хеш‑значения в номер бакета или слота обычно выполняется с помощью операции нахождения остатка от деления. Однако операция остатка от деления (%) довольно затратна по числу тактов процессора. Но если делитель — это степень двойки, то операцию% можно заменить на сверхбыструю битовую маску младших n битов. По этой причине многие, если не большинство, хеш‑таблиц ограничены размерами, кратными степеням двойки.
## Производительность операций

| Операция | Средний случай | Худший случай |
|----------|----------------|---------------|
| Вставка  | O(1)           | O(n)          |
| Поиск    | O(1)           | O(n)          |
| Удаление | O(1)           | O(n)          |

#### Практическая производительность зависит от:
- **Качества хеш-функции**
- **Коэффициента заполнения** (load factor) α = n/m
- **Метода разрешения коллизий**

---
## Основная идея

Использование **хеш-функции** для преобразования ключа(может быть любого типа и любой длины) в hash(индекс массива фиксированой длины), где будет храниться значение.

```
Ключ → Хеш-функция → Индекс → Массив → Значение
```

## Хеш-функции

### Требования к хорошей хеш-функции:
1. **Детерминированность** — один ключ всегда дает один хеш(так называемая чистота функции в терминах функционального программирования)
2. **Равномерное распределение** — ключи равномерно распределяются по индексам
3. **Необратимость** hash функции (отсутствие обратной функции/операции для hash функции)
4. **Минимизация коллизии** — минимум совпадений хешей для разных ключей

---
## Коллизии и методы их разрешения

**Коллизия** — ситуация, когда для двух и более разных ключей hash-функция выдала одинаковые hash(hash-индекс).

В хеш-таблицах коллизии (ситуации, когда разные ключи имеют одинаковый хеш) неизбежны. По той простой причине что в качестве ключа может выступать обьекты любой природы и людой длины/размера а hash как правило имеет фиксированную длину(например std::size_t). Такой подход разумеется приводит к некоторой потере информации в приобразорвании(вычислении hash) и возможны пересечения(Пытаемся разместить потенциально бесконечно большой набор данных в фиксированный набор данных). В связи с этим существую разные стратегии разрешения коллизий:

### 1. **Метод цепочек ([[Separate Chaining]])**
   - **Суть**: Каждая ячейка таблицы содержит связный список (или другую структуру) элементов с одинаковым хешем.
   - **Как работает**:
     - При коллизии новый элемент добавляется в список соответствующей ячейки.
     - Поиск проходит по списку в ячейке.
   - **Плюсы**:
     - Простота реализации.
     - Таблица не переполняется (можно добавлять сколько угодно элементов).
   - **Минусы**:
     - Дополнительные расходы памяти на хранение указателей.
     - При большой коллизии поиск может деградировать до O(n).

### 2. **Открытая адресация ([[Open Addressing]])**
   - **Суть**: Все элементы хранятся непосредственно в массиве хеш-таблицы. При коллизии ищется следующая свободная ячейка.
   - **Основные стратегии поиска места**:
     - **Линейное пробирование**: `h(k, i) = (h'(k) + i) % m`
       - Простое перемещение на следующую ячейку.
       - Проблема: кластеризация (образуются длинные последовательности занятых ячеек).
     - **Квадратичное пробирование**: `h(k, i) = (h'(k) + c₁i + c₂i²) % m`
       - Уменьшает кластеризацию, но может не охватить все ячейки.
     - **Двойное хеширование**: `h(k, i) = (h₁(k) + i*h₂(k)) % m`
       - Используется вторая хеш-функция для шага.
       - Наиболее равномерное распределение.
   - **Плюсы**:
     - Не нужны дополнительные структуры данных.
     - Лучшая локальность кэша (все данные в одном массиве).
   - **Минусы**:
     - Максимальный размер ограничен размером таблицы.
     - При высокой заполненности производительность падает.

### 3. **[[Robin Hood Hashing]]** (Улучшенная открытая адресация)
   - **Суть**: При вставке элемента, если он оказывается дальше от "идеальной" позиции, чем уже находящийся там элемент, они меняются местами.
   - **Плюсы**:
     - Более равномерное распределение.
     - Уменьшается среднее время поиска.
   - **Минусы**:
     - Сложнее реализация.
     - Дорогая вставка.

### 4. **[[Cuckoo Hashing]]**
   - **Суть**: Используется 2 (или более) хеш-функции и соответствующие таблицы.
     - Элемент помещается в одну из возможных ячеек.
     - Если ячейка занята, старый элемент "вытесняется" в свою альтернативную позицию.
   - **Плюсы**:
     - Гарантированное O(1) время поиска в худшем случае.
   - **Минусы**:
     - Сложная вставка (может потребовать рехеширования всей таблицы).
     - Нужно несколько хеш-функций.

### 5. **[[Hopscotch Hashing]]**
   - **Суть**: Комбинация открытой адресации и метода цепочек.
     - Каждая ячейка содержит информацию о соседних ячейках в пределах "окрестности".
     - Позволяет эффективно искать элементы вблизи их идеальной позиции.
   - **Плюсы**:
     - Хорошая производительность при высокой нагрузке.
   - **Минусы**:
     - Сложная реализация.


### Выбор стратегии зависит от:
- Ожидаемого количества элементов.
- Требований к скорости поиска/вставки.
- Доступной памяти.
- Важности времени выполнения в худшем случае.

**На практике**:
- Для общего назначения часто используют **метод цепочек** (как в Java `HashMap`) или **открытую адресацию** с двойным хешированием (как в Python `dict`).
- В высоконагруженных системах могут применяться **Robin Hood** или **Cuckoo hashing**.


---
## Rehashing(Перехеширование)
##### Увеличение размера хеш-таблицы
Когда хеш‑таблица заканчивает свободные слоты, она увеличивает размер, обычно удваивая массив(rehashing). Все существующие элементы перехешируются и заново вставляются в новый массив. Однако таблицы с открытой адресацией не ждут полного заполнения массива, прежде чем расширяться. Почему? 

Чем больше заполнен массив, тем длиннее средняя последовательность пробирования.
В примере с ключом 25 нам пришлось пройти 4 слота, чтобы найти пустой.
Если останется только 1 пустой слот, в худшем случае придётся сканировать весь массив **O(n)**.

Чтобы этого избежать, хеш‑таблицы вводят порог заполненности (**load factor**). Обычно он составляет **70–90**%. Когда количество занятых слотов превышает этот порог, таблица расширяется, чтобы избежать слишком длинных последовательностей пробирования.*
##### **Стратегии перехеширования:**
- **Удвоение размера** (наиболее распространено)
- **Увеличение до ближайшего простого числа**
- **Инкрементальное перехеширование**

---
## Коэффициент заполнения (Load Factor)

**Load factor** (обозначается как **α**, "альфа") — это **мера заполненности** хеш-таблицы. Он показывает, **какая часть ячеек массива занята элементами**.

**α = n/m**, где:
- n — количество элементов
- m — размер таблицы

Чем больше заполнен массив(чем ближе α к 1), тем длиннее средняя последовательность пробирования.
Если останется только 1 пустой слот к примеру, в худшем случае придётся сканировать весь массив **O(n)** и тогда операции над таблицей перестают работать за аммортизированное **O(1)**. 

**Рекомендации:**
- **Метод цепочек**: α < 0.9
- **Открытая адресация**: α < 0.7
- **При превышении**: требуется **rehashing** (увеличение размера)

---

## Смотри:
### [[Perfect Hashing]]
### [[Double Hashing]]
### [[Swiss Table]]
