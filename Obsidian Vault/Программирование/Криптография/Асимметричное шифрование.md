
1.  **Ты берёшь два ОГРОМНЫХ простых числа.** Допустим, это `p = 17` и `q = 23` (в реальности они длиной в сотни цифр). Это твой **главный секрет**, твой "trapdoor".
2.  **Ты перемножаешь их:** `n = p * q = 391`. Это число `n` — твой **открытый ключ**, "витрина" твоего сейфа. Ты можешь смело раздавать его всем.
3.  **Магия в том, что зная только `n` (391), практически невозможно догадаться, что его создали из 17 и 23.** Единственный способ — перебрать все простые числа, которые могут быть делителями. Для маленького числа 391 это ещё можно сделать, но когда `n` длиной в 600 цифр... это займёт время, сравнимое с возрастом Вселенной.

---
### Ваша криптосистема "в лоб" (назовём её "Умножитель-Делитель")

**Генерация ключей:**
*   Вы выбираете свои гигантские простые `p` и `q`.
*   Вычисляете `n = p * q`.
*   **Публичный ключ:** `n`
*   **Приватный ключ:** `p` (достаточно одного, ведь `q = n / p`).

**Шифрование (отправитель):**
*   У отправителя есть сообщение `M`, которое он хочет зашифровать.
*   Он делает: `Шифротекст = M * n`.
*   И отправляет вам это произведение.

**Расшифровка (вы, получатель):**
*   Вы получаете `Шифротекст`.
*   Вы делаете: `M = Шифротекст / p`.
*   Сообщение расшифровано!

---

### почему это ужасная идея на практике

**Плюс:**
*   **Простота:** Данный  способ демонстрирует самую суть асимметричного шифрования. Мы использовали `n` для шифрования и секрет `p` для дешифровки. Без `p` восстановить `M` из `M*n` так же сложно, как факторизовать `n`.

**Минусы (почему так не делают):**

1.  **Раздувание размера:** Если ваше сообщение `M` было, скажем, 100 КБ, то шифротекст `M * n` станет гигантским. Для 2048-битного `n` вы увеличиваете каждое сообщение на 256 байт. Это очень неэффективно.

2.  **ОЧЕНЬ НЕНАДЁЖНО:** Это самая главная проблема.
    *   **Атака 1:** Что, если мое сообщение `M` — это ноль? Тогда шифротекст тоже ноль. Любой перехватчик это увидит.
    *   **Атака 2:** Что, если мое сообщение `M` — это единица? Тогда шифротекст будет равен `n`. Я только что раскрыл ваш публичный ключ в чистом виде!
    *   **Атака 3 (самая страшная):** Злоумышленник может отправить вам на расшифровку специально сконструированное "сообщение", например, просто число `2`. Получив от вас ответ (расшифрованное значение), он сможет провести анализ и вскрыть ваш секрет. Ваша схема **"пластична"** — она не сопротивляется целенаправленным атакам.


### Так зачем же вся "мишура" с `e`, `d` и `mod n`?

**Вся эта "мишура" — это чтобы исправить недостатки вашей простой и красивой схемы!**

1. **`mod n`** — чтобы результат шифрования всегда был меньше `n`. Он **не раздувается** в размере. Зашифрованное сообщение по длине такое же, как и исходное.
    
2. **Степени (`M^e`) и секретная экспонента `d`** — чтобы сделать операцию **нелинейной** и **стойкой к атакам**. Злоумышленник не может предсказать, как изменится шифротекст, если он изменит сообщение. Он не может подставлять вам "2" для анализа. Эта нелинейность ломает все простые атаки, которые убивают ваш "Умножитель-Делитель".

---

### Как это работает на практике? Полный цикл для Боба и Алисы

**Шаг 1: Генерация ключей (Боб создаёт свой сейф)**

1.  Боб выбирает два тайных простых числа-гиганта `p` и `q`.
2.  Вычисляет `n = p * q`. Это первая часть его открытого ключа.
3.  Выбирает ещё одно число `e` (обычно 65537). Это вторая часть открытого ключа. Теперь у Боба есть **открытый ключ: (e, n)**.
4.  Используя **(p, q, e)** Боб вычисляет своё **секретное число `d`**. Это и есть его **закрытый ключ**.

**Итог:**
*   **Открытый ключ Боба (замочек):** `(e, n)` — он публикует его для всех.
*   **Закрытый ключ Боба (ключик):** `(d, n)` — хранит в строжайшем секрете.

**Шаг 2: Шифрование (Алиса закрывает сообщение в сейф Боба)**

Алиса хочет отправить Бобу секретное число `m` (в реальности текст сначала превращают в число).

1.  Она берёт открытый ключ Боба `(e, n)`.
2.  Она вычисляет шифрограмму `c` по простой (для компьютера) формуле:
    **`c = m^e % n`**
    
    То есть, она берет своё сообщение `m`, возводит его в степень `e` и находит остаток от деления на гигантское число `n`.

**Шаг 3: Расшифрование (Боб открывает сейф своим ключом)**

Боб получает зашифрованное число `c`.

1.  Он использует свой секретный ключ `d`.
2.  Он вычисляет исходное сообщение по волшебной формуле:
    **`m = c^d % n`**
    
    То есть, он берет шифр `c`, возводит его в свою секретную степень `d` и находит остаток от деления на `n`.

---

### Итог

**RSA целиком и полностью основан на асимметрии между сложностью умножения и сложностью разложения на множители.**

1.  **Создание ключа:** `p * q = n` (легко).
2.  **Шифрование:** `m^e mod n = c` (легко).
3.  **Расшифрование (без секрета):** Найти `m` из `c`, зная только `n` и `e` (практически невозможно).
4.  **Расшифрование (с секретом):** `c^d mod n = m` (легко, если знаешь `d`, а `d` можно вычислить, только зная `p` и `q`).

Таким образом, твой "философский камень" — это и есть **пара больших простых чисел**. Тот, кто владеет этим камнем, владеет "лазейкой" во всей системе.