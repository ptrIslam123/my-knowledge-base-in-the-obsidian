**Read-Copy-Update (RCU)** — это механизм синхронизации, используемый в ядре Linux и высоконагруженных системах для **беспроблемного чтения данных** при их параллельном обновлении. Он идеально подходит для сценариев, где чтение происходит часто, а запись редко.

---

## **1. Основная идея**
RCU позволяет:
- **Читателям** получать доступ к данным **без блокировок** (читают даже во время обновления).  
- **Писателям** обновлять данные **без блокировки читателей**, но с гарантией безопасного удаления старых данных.  

**Ключевой принцип**:  
> "Читатели видят либо старую, либо новую версию данных, но никогда частично обновлённую."

---

## **2. Как это работает?**
### **a) Структура данных**
```c
struct rcu_data {
    int value;
    // Другие поля...
};
struct rcu_data *ptr = new rcu_data{42}; // Разделяемый указатель
```

### **b) Чтение (Lock-Free)**
```c
// Читатель 1
rcu_read_lock(); // Начало критической секции чтения
struct rcu_data *local_ptr = ptr; // Чтение указателя
printf("%d", local_ptr->value);   // Доступ к данным
rcu_read_unlock(); // Конец критической секции
```
- Читатели **не блокируются** и работают параллельно.
- Даже если писатель обновляет `ptr`, читатели продолжают видеть старый указатель.

### **c) Запись (Grace Period)**
```c
// Писатель
struct rcu_data *new_ptr = new rcu_data{100}; // Новая версия
struct rcu_data *old_ptr = ptr;
ptr = new_ptr; // Атомарно обновляем указатель

// Ожидаем, пока все читатели завершат работу со старыми данными
synchronize_rcu(); // "Период милосердия" (Grace Period)

delete old_ptr; // Безопасное удаление старых данных
```
- `synchronize_rcu()` ждёт, пока **все существующие читатели** завершат свои `rcu_read_lock()` секции.
- После этого старые данные можно удалять.

---

## **3. Преимущества RCU**
| Плюс                  | Пояснение                                                                 |
|-----------------------|--------------------------------------------------------------------------|
| **Высокая скорость чтения** | Читатели не блокируются и работают параллельно.                         |
| **Масштабируемость**       | Нет contention между читателями (в отличие от мьютексов).               |
| **Гибкость**               | Подходит для сложных структур (списки, хеш-таблицы).                    |
| **Отсутствие deadlock**    | Нет блокировок → нет взаимоблокировок.                                  |

---

## **4. Ограничения**
| Минус                 | Пояснение                                                                 |
|-----------------------|--------------------------------------------------------------------------|
| **Задержки при записи** | `synchronize_rcu()` может быть медленным (ожидание читателей).          |
| **Память**             | Старые данные не удаляются мгновенно (требуют Grace Period).            |
| **Сложность**          | Трудно реализовать без поддержки ядра (в user-space редко используется).|

---

## **5. Где применяется?**
1. **Ядро Linux**:
   - Файловые системы (например, VFS).
   - Сетевые подсистемы (таблицы маршрутизации).
   - Управление процессами.

2. **Базы данных**:
   - Lock-free чтение журналов транзакций.

3. **Высоконагруженные серверы**:
   - Кэши конфигураций, которые редко обновляются.

---

## **6. Пример в ядре Linux**
```c
// Чтение списка процессов
struct task_struct *task;
rcu_read_lock();
list_for_each_entry_rcu(task, &tasks, list) {
    printk("PID: %d\n", task->pid);
}
rcu_read_unlock();

// Обновление списка
struct task_struct *new_task = kmalloc(...);
list_add_rcu(&new_task->list, &tasks); // Добавляем новый элемент
synchronize_rcu(); // Ждём завершения всех читателей
kfree(old_task);   // Удаляем старый
```

---

## **7. Аналогии**
- **Библиотека**:  
  - Читатели берут книги даже во время ремонта (обновления каталога).  
  - Старые каталоги выбрасывают, только когда все читатели их вернули.  

- **Google Docs**:  
  - Пользователи видят либо старую, либо новую версию документа, но не частичные изменения.  

---

## **8. Реализация в user-space**
Хотя RCU сложен без поддержки ядра, есть библиотеки:
- **Userspace RCU** (liburcu) — портирование RCU для приложений.
- **Пример**:
  ```c
  #include <urcu.h>
  rcu_read_lock();
  // Чтение данных...
  rcu_read_unlock();
  ```

---

## **9. Вывод**
- **RCU** — это мощный механизм для **частого чтения** и **редкой записи**.  
- Читатели **работают без блокировок**, писатели **гарантируют консистентность**.  
- Используется в ядре Linux и niche-оптимизациях.  
- Для user-space лучше подходят `std::shared_ptr` + `atomic` или другие lock-free структуры.  

**Когда выбирать RCU?**  
- Если чтение в 100+ раз чаще записи.  
- Если критична производительность читателей.  
- Если можно позволить задержки при обновлении.