# Роль различных `std::memory_order` в C++

```c++
enum memory_order  
{  
    memory_order_relaxed,  
    memory_order_consume,  
    memory_order_acquire,  
    memory_order_release,  
    memory_order_acq_rel,  
    memory_order_seq_cst  // default for all atomic operations 
};
```

`std::memory_order` определяет, как должны быть упорядочены обращения к памяти, включая обычные, неатомарные обращения к памяти, вокруг атомарной операции. 

Любая операция с `std::atomic<T>` будет выполнятся атомарно, но вот порядок применения этих операции может отличаться у других потоков от порядка того потока который собственно и совершил эти операции из-за различным оптимизации компилятора и процессора(потоков ядра), соотвенно за это поведение, а вернее за порядок в котором могу увидить эти изменения другие потоки, и отвечает std::memory_order - по сути это определяет какие барьеры, и будут ли они вообще использоваться с атомарными операциями. 

По умолчанию все атомарные операции в библиотеке обеспечивают _последовательно согласованное упорядочение_. По умолчанию это может снизить производительность, но атомарные операции библиотеки могут получить дополнительный `std::memory_order` аргумент для указания точных ограничений, помимо атомарности, которые компилятор и процессор должны применить для этой операции.

**Язык C++ предоставляет три способа синхронизации памяти. По мере возрастания строгости: `relaxed`, `release/acquire` и `sequential consistency`**.

| Значение               | Объяснение                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `memory_order_relaxed` | Расслабленная операция: не накладываются никакие ограничения на синхронизацию или порядок других чтений или записей, гарантируется только атомарность этой операции (см. [Расслабленное упорядочение](https://spec-zone.ru/cpp/atomic/memory_order#Relaxed_ordering) ниже).                                                                                                                                                                                                                                                                                                                                                                                               |
| `memory_order_consume` | Операция загрузки с данным порядком памяти выполняет _операцию потребления_ в указанном месте памяти: никакие чтения или записи в текущем потоке, зависящие от загруженного значения, не могут быть переупорядочены перед этой загрузкой. Записи в переменные, зависящие от данных, в других потоках, которые освобождают ту же атомарную переменную, видны в текущем потоке. На большинстве платформ это влияет только на оптимизации компилятора (см. [Упорядочение выпуска-потребления](https://spec-zone.ru/cpp/atomic/memory_order#Release-Consume_ordering) ниже).                                                                                                  |
| `memory_order_acquire` | Операция загрузки с этим порядком памяти выполняет _операцию захвата_ в указанном месте памяти: никакие чтения или записи в текущем потоке не могут быть переупорядочены перед этой загрузкой. Все записи в других потоках, которые освобождают ту же атомарную переменную, видны в текущем потоке (см. [Упорядочение выпуска-приобретения](https://spec-zone.ru/cpp/atomic/memory_order#Release-Acquire_ordering) ниже).                                                                                                                                                                                                                                                 |
| `memory_order_release` | Операция сохранения с этим порядком памяти выполняет _операцию выпуска_: никакие чтения или записи в текущем потоке не могут быть переупорядочены после этого сохранения. Все записи в текущем потоке видны в других потоках, которые приобретают ту же атомарную переменную (см. [Упорядочение выпуска-приобретения](https://spec-zone.ru/cpp/atomic/memory_order#Release-Acquire_ordering) ниже) и записи, которые вносят зависимость в атомарную переменную, становятся видимыми в других потоках, которые потребляют ту же атомарную переменную (см. [Упорядочение выпуска-потребления](https://spec-zone.ru/cpp/atomic/memory_order#Release-Consume_ordering) ниже). |
| `memory_order_acq_rel` | Операция чтения-модификации-записи с этим порядком памяти является как _операцией захвата_, так и _операцией выпуска_. Никакие чтения или записи памяти в текущем потоке не могут быть переупорядочены перед загрузкой, ни после сохранения. Все записи в других потоках, которые освобождают ту же атомарную переменную, видны перед модификацией, и модификация видна в других потоках, которые приобретают ту же атомарную переменную.                                                                                                                                                                                                                                 |
| `memory_order_seq_cst` | Операция загрузки с этим порядком памяти выполняет _операцию захвата_, сохранение выполняет _операцию выпуска_, а чтение-модификация-запись выполняет как _операцию захвата_, так и _операцию выпуска_, плюс существует единственный общий порядок, в котором все потоки наблюдают все модификации в одном порядке (см. [Последовательно согласованное упорядочение](https://spec-zone.ru/cpp/atomic/memory_order#Sequentially-consistent_ordering) ниже).                                                                                                                                                                                                                |
# std::memory_order_relaxed(Расслабленная упорядоченность) — минимальные гарантии

**Атомарные операции, помеченные `memory_order_relaxed`, не являются операциями синхронизации; они не накладывают порядок между одновременными обращениями к памяти. Они гарантируют только атомарность и согласованность порядка модификаций.**
```c++
// при `x` и `y` изначально равных нулю,

// Thread 1:
r1 = y.load(std::memory_order_relaxed); // A
x.store(r1, std::memory_order_relaxed); // B

// Thread 2:
r2 = x.load(std::memory_order_relaxed); // C 
y.store(42, std::memory_order_relaxed); // D
```

разрешено получить `r1 == r2 == 42`, потому что, хотя A _предшествует_ B в потоке 1 и C _предшествует_ D в потоке 2, ничего не мешает D появиться перед A в порядке модификации y и B перед C в порядке модификации x. Иначе говоря, нет гарантии что все операции совершаемые 1 потоком(A & B), будут видны потоку 2 в таком же порядке что и потоку 1, тоже самое верно что нет гаратии что поток все операции совершаемые потоком 2(C & D) будут видны потоку 1 в том же порядке что потоку 2 

1. **Нет гарантий порядка** между операциями в разных потоках (кроме атомарности).
2. **Внутри одного потока** операции можно переупорядочивать, **если нет зависимостей по данным**.
3. **Единственная гарантия** — каждая операция чтения/записи атомарна (не будет "разорванных" значений).

**Типичное применение для расслабленной упорядоченности памяти — инкрементирование счетчиков, таких как счётчики ссылок `std::shared_ptr`, так как это требует только атомарности, но не упорядочения или синхронизации. Обратите внимание, что декрементирование счетчиков `std::shared_ptr` требует синхронизации acquire-release с деструктором (Перед удалением объекта нужно убедиться, что все операции с ним в других потоках завершены (например, если другой поток читал данные объекта, они должны быть видны до деструктора. Это гарантирует, что деструктор не начнётся, пока другие потоки используют объект).**
### Пример правильного использования

```c++
std::atomic<bool> isReady{false};

void thread1() {
    while (isReady.load(std::memory_order_relaxed) == true) {  // (1)
	    // ... do something with non shared data
    }
}

void thread2() {
    isReady.store(true, std::memory_order_relaxed);  // (2)
}
```

В данном примере не важен порядок в котором `thread1` увидит изменения из потока, вызывающего `thread2`. Также не важно то, чтобы `thread1` мгновенно (синхронно) увидел выставление флага `isReady` в `true`.

#### Пример кода который должен работать но не работает как ожидается из-за эффектов memory_order_relaxed(Опасный код)

```c++
std::atomic<bool> isReady{false};
std::string data;

void thread1() {
    while (isReady.load(std::memory_order_relaxed) == true) {  // (1)
        // Может не выполниться, даже если flag == true!
        assert(!data.empty()); // (2) Потенциальные проблемы
    }
}

void thread2() {
    data = "some data";                          // (3)
    // тут возможно переупоряочивание операции компилятором(нету барьера)
    isReady.store(true, std::memory_order_relaxed);  // (4)
}
```

Тут нет гарантий, что поток `thread1` увидит изменения `data` ранее, чем изменение флага `isReady`, т.к. синхронизацию памяти флаг `relaxed` не обеспечивает.

# Синхронизация пары-Acquire/Release 

**Флаг синхронизации памяти `acquire/release` является более тонким способом синхронизировать данные между парой потоков. Два ключевых слова: `memory_order_acquire` и `memory_order_release` работают только в паре над одним атомарным объектом**.

**Release-Acquire** — это механизм синхронизации между потоками, который гарантирует, что:
- Все операции **до** `store` с `release` будут видны потоку, который выполняет `load` с `acquire`.
- Запрещает переупорядочивание операций "вверх" через `release` и "вниз" через `acquire`.
- `release` и `acquire` работают **только для одной атомарной переменной**. Если у вас несколько флагов, нужны дополнительные механизмы (например, `seq_cst`).
- На x86 `release-acquire` почти бесплатно (нет барьеров), на ARM требует `dmb`.

```c++
std::atomic<bool> is_ready{false};
int data1 = 0;
int data2 = 0;

void producer() {
    data1 = 100;
    data2 = 200;                          // (1) Записываем данные
    is_ready.store(true, std::memory_order_release); // (2) Release-операция
}

void consumer() {
    while (!is_ready.load(std::memory_order_acquire)) { // (3) Acquire-операция
        // Ждём, пока данные будут готовы
    }
    assert(data1 == 100 && data2 == 200); // (4) Гарантированно увидит 100
}
```

**Что гарантируется?**
1. Операция `data = 100` (1) **всегда выполнится до** `ready.store` (2) благодаря `release`.
2. Поток `consumer` **увидит `data = 42`**, потому что `acquire` гарантирует, что все изменения до `release` уже видны.


```c++
bool is_ready{false};
int data1 = 0;
int data2 = 0;

void producer() {
    data1 = 100;
    data2 = 200;                      // (1) Обычная запись
    std::atomic_thread_fence(std::memory_order_release); // (2) Процессорный барьер
    __atomic_store_n(&is_ready, true, __ATOMIC_RELAXED); // (3) Атомарная запись
}

void consumer() {
    while (!__atomic_load_n(&is_ready, __ATOMIC_RELAXED)) { // (4) Атомарное чтение
    }
    std::atomic_thread_fence(std::memory_order_acquire); // (5) Процессорный барьер
    assert(data1 == 100 && data2 == 200); // (6) Может ли упасть?
}
```

#### **Сходства с `std::atomic` + `release-acquire`**:
1. **Гарантии порядка**:
    - `release`-барьер (2) запрещает переупорядочивание записей `data1/data2` после записи `is_ready`.
    - `acquire`-барьер (5) запрещает переупорядочивание чтений `data1/data2` до чтения `is_ready`.
    
2. **На x86** (сильная модель памяти):
    - Ваш код будет работать корректно, так как:
        - `std::atomic_thread_fence(release)` компилируется в `no-op` (барьеры не нужны, x86 и так упорядочивает store'ы).
        - `std::atomic_thread_fence(acquire)` тоже `no-op` (чтения и так имеют acquire-семантику).
    
3. **На архитектурах с сильной моделью** (x86, SPARC):
    - Ваш код **полностью эквивалентен** `std::atomic` + `release-acquire`.
    
### **2. Где ваш код может сломаться?**

#### **Проблемы на слабых архитектурах (ARM, PowerPC, RISC-V)**:

1. **Отсутствие связи барьеров с переменной `is_ready`**:
    - В `std::atomic` с `release-acquire` синхронизация привязана к конкретной переменной (`is_ready`).
    - В вашем коде барьеры общие, и процессор может "не понять", что они связаны с `is_ready`.
    
2. **Недостаточная строгость барьеров**:
    - На ARM/PowerPC:
        - `release`-барьер (`std::atomic_thread_fence(release)`) обычно реализуется как `dmb ishst` (барьер только для store'ов).
        - `acquire`-барьер (`std::atomic_thread_fence(acquire)`) — как `dmb ish` (полный барьер).
        - Но этого **может быть недостаточно**, если процессор агрессивно переупорядочивает операции.
    
3. **Оптимизации компилятора**:
    - Компилятор может переупорядочить операции вокруг барьеров, если не видит явной связи с `is_ready`.


# Упорядоченность release-consume
Если атомарная запись в потоке A помечена `memory_order_release`, а атомарная загрузка в потоке B из той же переменной помечена `memory_order_consume`, и загрузка в потоке B читает значение, записанное записью в потоке A, то запись в потоке A _зависимо упорядочена до_ загрузки в потоке B.

Все записи в память (не атомарные и атомарные с ослабленным порядком), которые _предшествовали_ атомарной записи с точки зрения потока A, становятся _видимыми побочными эффектами_ в тех операциях в потоке B, в которые загрузка операции _переносит зависимость_, то есть после завершения атомарной загрузки те операторы и функции в потоке B, которые используют значение, полученное из загрузки, гарантированно увидят то, что поток A записал в память.

Синхронизация устанавливается только между потоками, _освобождающими_ и _потребляющими_ ту же атомарную переменную. Другие потоки могут видеть различный порядок обращений к памяти, чем синхронизированные потоки.

На всех распространённых процессорах, кроме DEC Alpha, упорядоченность зависимости автоматична, для этого режима синхронизации не выдаются дополнительные инструкции процессора, затрагиваются только определённые оптимизации компилятора (например, компилятор запрещено выполнять спекулятивные загрузки объектов, которые участвуют в цепочке зависимостей).

Типичные случаи использования этой упорядоченности включают чтение редко записываемых разделяемых структур данных (таблицы маршрутизации, конфигурации, политики безопасности, правила брандмауэра и т. д.) и ситуации издатель-подписчик с публикацией через указатели, то есть когда производитель публикует указатель, через который потребитель может получить доступ к информации: нет необходимости делать всё, что производитель записал в память, видимым для потребителя (что может быть дорогостоящей операцией на слабо упорядоченных архитектурах). Примером такой ситуации является [rcu_dereference](https://en.wikipedia.org/wiki/Read-copy-update "enwiki:Read-copy-update").

Обратите внимание, что в настоящее время (2/2015) не известно ни одного производственного компилятора, отслеживающего цепочки зависимостей: операции consume поднимаются до операций acquire.

|                                                                                                                                  |           |
| -------------------------------------------------------------------------------------------------------------------------------- | --------- |
| Спецификация упорядоченности release-consume пересматривается, и использование `memory_order_consume` временно не рекомендуется. | (с C++17) |

# Cамое строгое - std::memory_order_seq_cst 
- **порядок модификаций разных атомарных переменных в потоке `thread1` сохранится в потоке `thread2`**

- все потоки будут видеть один и тот же порядок модификации всех атомарных переменных. Сами модификации могут происходить в разных потоках

- все модификации памяти (не только модификации над атомиками) в потоке `thread1`, выполняющей `store` на атомарной переменной, будут видны после выполнения `load` этой же переменной в потоке `thread2`


Таким образом можно представить `seq_cst` операции, как барьеры памяти, в которых состояние памяти синхронизируется между всеми потоками программы.

Этот флаг синхронизации памяти в C++ используется по умолчанию, т.к. с ним меньше всего проблем с точки зрения корректности выполнения программы. Но `seq_cst` является дорогой операцией для процессоров, в которых вычислительные ядра слабо связаны между собой в плане механизмов обеспечения консистентности памяти. Например, для x86-64 `seq_cst` дешевле, чем для ARM архитектур.

### Пример

```c++
std::atomic<bool> x, y;
std::atomic<int> z;
 
void thread_write_x() {
	x.store(true, std::memory_order_seq_cst);
}
 
void thread_write_y() {
	y.store(true, std::memory_order_seq_cst);
}
 
void thread_read_x_then_y() {
	while (!x.load(std::memory_order_seq_cst));
	if (y.load(std::memory_order_seq_cst)) {
		++z;
	}
}
 
void thread_read_y_then_x() {
	while (!y.load(std::memory_order_seq_cst));
	if (x.load(std::memory_order_seq_cst)) {
		++z;
	}
}
```

После того, как все четыре потока отработают, значение переменной `z` будет равно `1` или `2`, потому что потоки `thread_read_x_then_y` и `thread_read_y_then_x` "увидят" изменения `x` и `y` в одном и том же порядке. От запуска к запуску это могут быть: сначала `x = true`, потом `y = true`, или сначала `y = true`, потом `x = true`.

Модификатор `seq_cst` всегда может быть использован вместо `relaxed` и `acquire/release`, еще и поэтому он является модификатором по умолчанию.


### **Рекомендации по платформам**
1. **x86-64**:
    - `release-acquire` почти бесплатен → всегда предпочитайте его `relaxed`, если есть хоть какая-то необходимость в синхронизации.
    
    - `seq_cst` дорог только для `store` → избегайте в горячих путях.
    
2. **ARM (мобильные/серверы)**:
    - `release-acquire` требует барьеров → используйте только где нужно.
    
    - `seq_cst` очень дорог → пересматривайте алгоритмы (например, RCU вместо мьютексов).
    
3. **PowerPC/RISC-V**:
    
    - Аналогично ARM, но барьеры ещё дороже.
    
    - Минимизируйте количество атомарных операций.

### **Иерархия производительности (от самого быстрого к самому медленному)**
#### **1. Все платформы (x86, ARM, PowerPC, RISC-V)**
| `memory_order`       | Относительная стоимость | Примечания                                                                 |
|-----------------------|-------------------------|----------------------------------------------------------------------------|
| **relaxed**          | 1 (самый быстрый)       | Нет барьеров, только атомарность.                                          |
| **consume**          | ≈ `acquire`             | Фактически не работает, компиляторы заменяют на `acquire`.                 |
| **release/acquire**  | 1–3                     | На x86 почти бесплатно, на ARM/PowerPC требует барьеров (`dmb`, `lwsync`). |
| **acq_rel**          | 2–4                     | Комбинация `acquire` + `release`.                                          |
| **seq_cst**          | 3–10                    | Самый дорогой (особенно `store` на x86 требует `mfence`).                  |

### **2. Различия по платформам**
#### **x86/x86-64 (сильная модель памяти)**
- `relaxed` = `release` = `acquire` = **1** (одинаково быстро, барьеры не нужны).
- `seq_cst`:
  - `load`: 1 (как `acquire`).
  - `store`: 5–10 (требует `mfence`).

#### **ARM/PowerPC/RISC-V (слабая модель памяти)**
- `relaxed`: 1.
- `release`/`acquire`: 3–4 (требует `dmb ish` или `lwsync`).
- `seq_cst`: 6–10 (полные барьеры для всех операций).
