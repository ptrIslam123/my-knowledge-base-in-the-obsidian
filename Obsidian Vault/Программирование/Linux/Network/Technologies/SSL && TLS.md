### **Общие сведения о TLS**
Протокол **TLS(transport layer security)** основан на протоколе **SSL(Secure Sockets Layer)**, изначально разработанном в Netscape для повышения безопасности электронной коммерции в Интернете. Протокол SSL был реализован на application-уровне, непосредственно над TCP (Transmission Control Protocol), что позволяет более высокоуровневым протоколам (таким как HTTP или протоколу электронной почты) работать без изменений. Если SSL сконфигурирован корректно, то сторонний наблюдатель может узнать лишь параметры соединения (например, тип используемого шифрования), а также частоту пересылки и примерное количество данных, но не может читать и изменять их.

Конкретное место TLS (SSL) в стеке протоколов Интернета показано на схеме:
![[tsl6b10eda5d4c24928819a7a2e88fd3acd.png]]


После того, как протокол SSL был стандартизирован IETF (Internet Engineering Task Force), он был переименован в TLS. Поэтому хотя имена SSL и TLS взаимозаменяемы, они всё-таки отличаются, так как каждое описывает другую версию протокола.  

**`Как уже говорилось, TLS был разработан для работы над TCP, однако для работы с протоколами дейтаграмм, такими как UDP (User Datagram Protocol), была разработана специальная версия TLS, получившая название DTLS (Datagram Transport Layer Security).`** 
##### **Шифрование, аутентификация и целостность**
Протокол TLS предназначен для предоставления трёх услуг всем приложениям, работающим над ним, а именно: шифрование, аутентификацию и целостность. Технически, не все три могут использоваться, однако на практике, для обеспечения безопасности, как правило используются все три: 

- **Шифрование – сокрытие информации, передаваемой от одного компьютера к другому;**
- **Аутентификация – проверка авторства передаваемой информации;**
- **Целостность – обнаружение подмены информации подделкой.**
  
Для того чтобы установить криптографически безопасный канал данных, узлы соединения должны согласовать используемые методы шифрования и ключи. Протокол TLS однозначно определяет данную процедуру, подробнее это рассмотрено в пункте **TLS Handshake**. Следует отметить, что TLS использует криптографию с открытым ключом, которая позволяет узлам установить общий секретный ключ шифрования без каких-либо предварительных знаний друг о друге.  
  
Также в рамках процедуры TLS Handshake имеется возможность установить подлинность личности и клиента, и сервера. Например, клиент может быть уверен, что сервер, который предоставляет ему информацию о банковском счёте, действительно банковский сервер. И наоборот: сервер компании может быть уверен, что клиент, подключившийся к нему – именно сотрудник компании, а не стороннее лицо (данный механизм называется Chain of Trust и будет рассмотрен в соответствующем разделе).  
  
Наконец, TLS обеспечивает отправку каждого сообщения с кодом **MAC(Message Authentication Code)**, алгоритм создания которого – односторонняя криптографическая функция хеширования (фактически – контрольная сумма), ключи которой известны обоим участникам связи. Всякий раз при отправке сообщения, генерируется его MAC-значение, которое может сгенерировать и приёмник, это обеспечивает целостность информации и защиту от её подмены.  

### **TLS Handshake**
Перед тем, как начать обмен данными через TLS, клиент и сервер должны согласовать параметры соединения, а именно: **версия используемого протокола**, **способ шифрования данных**, а также проверить **сертификаты**, если это необходимо. Схема начала соединения называется **TLS Handshake** и показана на рисунке:
![[tlse5238736493f41489f5df57f94310962.png]]

Разберём подробнее каждый шаг данной процедуры: 
1. Так как TLS работает над TCP, для начала между клиентом и сервером устанавливается TCP-соединение.

2. После установки TCP, клиент посылает на сервер спецификацию в виде обычного текста (а именно версию протокола, которую он хочет использовать, поддерживаемые методы шифрования).

3. Сервер утверждает версию используемого протокола, выбирает способ шифрования из предоставленного списка, прикрепляет свой сертификат и отправляет ответ клиенту (при желании сервер может так же запросить клиентский сертификат).

4. Версия протокола и способ шифрования на данном моменте считаются утверждёнными, клиент проверяет присланный сертификат и инициирует либо **RSA**, либо обмен ключами по **Диффи-Хеллману**, в зависимости от установленных параметров.

5. Сервер обрабатывает присланное клиентом сообщение, сверяет MAC, и отправляет клиенту заключительное (‘Finished’) сообщение в зашифрованном виде.

6. Клиент расшифровывает полученное сообщение, сверяет MAC, и если всё хорошо, то соединение считается установленным и начинается обмен данными приложений.

**`Ясно, что установление соединения TLS является, вообще говоря, длительным и трудоёмким процессом, поэтому в стандарте TLS есть несколько оптимизаций. В частности, имеется процедура под названием “abbreviated handshake”, которая позволяет использовать ранее согласованные параметры для восстановления соединения (естественно, если клиент и сервер устанавливали TLS-соединение в прошлом). Данную процедура рассмотрена подробнее в пункте «Возобновление сессии».`**
  
**`Также имеется дополнительное расширение процедуры Handshake, которое имеет название TLS False Start. Это расширение позволяет клиенту и серверу начать обмен зашифрованными данными сразу после установления метода шифрования, что сокращает установление соединения на одну итерацию сообщений. Об этом подробнее рассказано в пункте “TLS False Start”.`**

### Подробное объяснение процесса TLS Handshake в SSL_connect()

Когда вызывается `SSL_connect(ssl)`, происходит сложный процесс установки безопасного соединения, известный как TLS Handshake. Давайте разберём его пошагово:

### Фазы TLS Handshake более формально
1. **Инициализация соединения (Client Hello)**
   - Клиент отправляет:
     - Поддерживаемые версии TLS (например, TLS 1.2, TLS 1.3)
     - Случайное число (Client Random)
     - Список поддерживаемых алгоритмов шифрования (Cipher Suites)
     - Список методов сжатия
     - Поддерживаемые расширения (SNI, ALPN и др.)

2. **Ответ сервера (Server Hello)**
   - Сервер отвечает:
     - Выбранную версию протокола
     - Случайное число (Server Random)
     - Выбранный алгоритм шифрования
     - Сертификат сервера (X.509)
     - (Опционально) Запрос сертификата клиента
     - Параметры ключевого обмена

3. **Аутентификация и обмен ключами**
   - Клиент проверяет сертификат сервера:
     - Проверка подписи CA
     - Проверка срока действия
     - Проверка соответствия имени хоста
     - Проверка отзыва (CRL/OCSP)
   - В зависимости от алгоритма:
     * **RSA**: Клиент генерирует pre-master secret, шифрует открытым ключом сервера
     * **Diffie-Hellman**: Стороны обмениваются параметрами и вычисляют общий секрет

4. **Завершение handshake**
   - Генерация мастер-ключа из pre-master secret и случайных чисел
   - Обмен сообщениями Finished с HMAC для проверки целостности
   - Переход к защищённому обмену данными

### **Обмен ключами в протоколе TLS**
По различным историческим и коммерческим причинам чаще всего в TLS используется обмен ключами по алгоритму **RSA**: клиент генерирует симметричный ключ, подписывает его с помощью открытого ключа сервера и отправляет его на сервер. В свою очередь, на сервере ключ клиента расшифровывается с помощью закрытого ключа. После этого обмен ключами объявляется завершённым. 

Данный алгоритм имеет один недостаток: эта же пара отрытого и закрытого ключей используется и для аутентификации сервера. Соответственно, если злоумышленник получает доступ к закрытому ключу сервера, он может расшифровать весь сеанс связи. Более того, злоумышленник может попросту записать весь сеанс связи в зашифрованном варианте и занять расшифровкой потом, когда удастся получить закрытый ключ сервера. В то же время, обмен ключами **Диффи-Хеллмана** представляется более защищённым, так как установленный симметричный ключ никогда не покидает клиента или сервера и, соответственно, не может быть перехвачен злоумышленником, даже если тот знает закрытый ключ сервера. На этом основана служба снижения риска компрометации прошлых сеансов связи: для каждого нового сеанса связи создаётся новый, так называемый **«временный» симметричный ключ**. Соответственно, даже в худшем случае (если злоумышленнику известен закрытый ключ сервера), злоумышленник может лишь получить ключи от будущих сессий, но не расшифровать ранее записанные.  
  
**`На текущий момент, все браузеры при установке соединения TLS отдают предпочтение именно сочетанию алгоритма Диффи-Хеллмана и использованию временных ключей для повышения безопасности соединения.`**  
  
**Следует ещё раз отметить, что шифрование с открытым ключом используется только в процедуре TLS Handshake во время первоначальной настройки соединения. После настройки туннеля в дело вступает симметричная криптография, и общение в пределах текущей сессии зашифровано именно установленными симметричными ключами. Это необходимо для увеличения быстродействия, так как криптография с открытым ключом требует значительно больше вычислительной мощности.**

### **TLS Chain of trust**  
Аутентификация является неотъемлемой частью каждого TLS соединения. Рассмотрим простейший процесс аутентификации между Алисой и Бобом:  

1. И Алиса, и Боб генерируют собственные открытые и закрытые ключи.
2. Алиса и Боб обмениваются открытыми ключами.
3. Алиса генерирует сообщение, шифрует его своим закрытым ключом и отправляет Бобу.
4. Боб использует полученный от Алисы ключ, чтобы расшифровать сообщение и таким образом проверяет подлинность полученного сообщения.

  
Очевидно, что данная схема построена на доверии между Алисой и Бобом. Предполагается, что обмен открытыми ключами произошёл, например, при личной встрече, и, таким образом, Алиса уверена, что получила ключ непосредственно от Боба, а Боб, в свою очередь, уверен, что получил открытый ключ Алисы.  
  
Пусть теперь Алиса получает сообщение от Чарли, с которым она не знакома, но который утверждает, что дружит с Бобом. Чтобы это доказать, Чарли заранее попросил подписать собственный открытый ключ закрытым ключом Боба, и прикрепляет эту подпись к сообщению Алисе. Алиса же сначала проверяет подпись Боба на ключе Чарли (это она в состоянии сделать, ведь открытый ключ Боба ей уже известен), убеждается, что Чарли действительно друг Боба, принимает его сообщение и выполняет уже известную проверку целостности, убеждаясь, что сообщение действительно от Чарли.

Описанное в предыдущем абзаце и есть создание «цепочки доверия» (или «Chain of trust», если по-английски).  
В протоколе TLS данные цепи доверия основаны на сертификатах подлинности, предоставляемых специальными органами, называемыми центрами сертификации (CA – certificate authorities). Центры сертификации производят проверки и, если выданный сертификат скомпрометирован, то данный сертификат отзывается.

**Из выданных сертификатов складывается уже рассмотренная цепочка доверия. Корнем её является так называемый “Root CA certificate” – сертификат, подписанный крупным центром, доверие к которому неоспоримо. В общем виде цепочка доверия выглядит примерно таким образом:**
![[tsla296340b4b8045fc9a87e75ef7a35d8d.png]]

**Естественно, возникают случаи, когда уже выданный сертификат необходимо отозвать или аннулировать (например, был скомпрометирован закрытый ключ сертификата, или была скомпрометирована вся процедура сертификации). Для этого сертификаты подлинности содержат специальные инструкции о проверке их актуальности. Следовательно, при построении цепочки доверия, необходимо проверять актуальность каждого доверительного узла.**

Механизм этой проверки прост и в его основе лежит т.н. «Список отозванных сертификатов» (CRL – «Certificate Revocation List»). У каждого из центров сертификации имеется данный список, представляющий простой перечень серийных номеров отозванных сертификатов. Соответственно любой, кто хочет проверить подлинность сертификата, попросту загружает данный список и ищет в нём номер проверяемого сертификата. Если номер обнаружится – это значит, что сертификат отозван.  
  
Здесь очевидно присутствует некоторая техническая нерациональность: для проверки лишь одного сертификата требуется запрашивать весь список отозванных сертификатов, что влечёт замедление работы. Для борьбы с этим был разработан механизм под названием «Протокол статусов сертификатов» (OCSP – Online Certificate Status Protocol). Он позволяет осуществлять проверку статуса сертификата динамически. Естественно, это снижает нагрузку на пропускную способность сети, но в то же время порождает несколько проблем:  

- Центры сертификации должны справляться с нагрузкой в режиме реального времени;
- Центры сертификации должны гарантировать свою доступность в любое время;
- Из-за запросов реального времени центры сертификации получают информацию о том, какие сайты посещал каждый конкретный пользователь.

  
Собственно, во всех современных браузерах оба решения (OCSP и CRL) дополняют друг друга, более того, как правило имеется возможность настройки предпочитаемой политики проверки статуса сертификата.


### Пример эхо сервера и клиента на TLS(c++)

## **1. Подготовка (генерация сертификатов)**

Перед запуском сгенерируйте сертификаты:
```bash
openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes
```
Ответьте на вопросы OpenSSL (можно оставить поля пустыми).

### TLS Client

```c++
#include <iostream>       // Для ввода/вывода (cout, cerr)
#include <cstring>        // Для работы со строками (strlen)
#include <sys/socket.h>   // Для работы с сокетами (socket, connect)
#include <arpa/inet.h>    // Для работы с IP-адресами (inet_pton)
#include <unistd.h>       // Для работы с файловыми дескрипторами (close)
#include <openssl/ssl.h>  // Основной заголовочный файл OpenSSL
#include <openssl/err.h>  // Для обработки ошибок OpenSSL

// Конфигурационные константы
const char* HOST = "127.0.0.1";  // Адрес сервера (localhost)
const int PORT = 8443;           // Порт сервера
const char* CERT_FILE = "cert.pem"; // Файл сертификата сервера

// Функция обработки ошибок
void handle_error(const char* msg) {
    perror(msg);
    ERR_print_errors_fp(stderr);
    exit(EXIT_FAILURE);
}

// Функция создания и настройки SSL контекста.
// содержит глобальные настройки и параметры для всех SSL/TLS соединений,
// созданных на его основе. Содержит: версию и метод протокола, сертификаты,
// ключи, параметры шифрования, настройки сессий
SSL_CTX* create_ssl_context() {
    // 1. Создаем новый SSL контекст для клиента
    SSL_CTX* ctx = SSL_CTX_new(TLS_client_method());
    if (!ctx) handle_error("Ошибка создания SSL контекста");
    
    // 2. Загружаем сертификат для проверки сервера
    // (в данном случае используется самоподписанный сертификат, сгенерированный)
    // нами и сохраненный в CERT_FILE файле
    if (SSL_CTX_load_verify_locations(ctx, CERT_FILE, nullptr) <= 0)
        handle_error("Ошибка загрузки сертификата");
    return ctx;  // Возвращаем настроенный контекст
}

int main() {
    // Инициализация библиотеки OpenSSL
    SSL_library_init();          // Инициализация SSL библиотеки
    OpenSSL_add_all_algorithms(); // Загрузка всех алгоритмов
    SSL_load_error_strings();    // Загрузка строк ошибок
    
    // Создаем и настраиваем SSL контекст
    SSL_CTX* ctx = create_ssl_context();
    
    /*** Создание TCP соединения ***/
    // 1. Создаем TCP сокет
    // AF_INET - IPv4, SOCK_STREAM - TCP, 0 - протокол по умолчанию
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) handle_error("Ошибка создания сокета");
    
    // 2. Настраиваем адрес сервера
    sockaddr_in server_addr{};
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    inet_pton(AF_INET, HOST, &server_addr.sin_addr);

    // 3. Устанавливаем соединение с сервером
    if (connect(sock, (sockaddr*)&server_addr, sizeof(server_addr)) < 0)
        handle_error("Ошибка подключения");
        
    /*** Настройка TLS соединения ***/
    // 1. Создаем новый SSL структуру для соединения
    SSL* ssl = SSL_new(ctx);
    // 2. Связываем SSL структуру с файловым дескриптором сокета
    SSL_set_fd(ssl, sock);
    // 3. Выполняем TLS handshake (установка безопасного соединения)
    if (SSL_connect(ssl) <= 0) 
	    handle_error("Ошибка SSL handshake");
    
    std::cout << "Подключение к серверу установлено!" << std::endl;
    
    /*** Обмен данными ***/
    // 1. Отправляем сообщение серверу
    const char* msg = "Hello from TLS Client!";
    // SSL_write аналогичен write(), но для защищенного соединения
    SSL_write(ssl, msg, strlen(msg));
    
    // 2. Получаем ответ от сервера
    char buf[1024];
    // SSL_read аналогичен read(), но для защищенного соединения
    int bytes = SSL_read(ssl, buf, sizeof(buf));
    if (bytes > 0) {
        buf[bytes] = '\0';  // Добавляем завершающий нуль
        std::cout << "Ответ сервера: " << buf << std::endl;
    }
    
    /*** Завершение работы ***/
    // 1. Корректно закрываем SSL соединение
    SSL_shutdown(ssl);
    // 2. Освобождаем ресурсы SSL
    SSL_free(ssl);
    // 3. Закрываем TCP соединение
    close(sock);
    // 4. Освобождаем SSL контекст
    SSL_CTX_free(ctx);
    return 0;
}
```

### TLS server
```c++
#include <iostream>       // Стандартный ввод/вывод
#include <string>         // Работа со строками
#include <cstring>        // Функции работы со строками C-style
#include <sys/socket.h>   // API сокетов BSD
#include <arpa/inet.h>    // Функции работы с IP-адресами
#include <unistd.h>       // POSIX API (close, read, write)
#include <openssl/ssl.h>  // Основной заголовочный файл OpenSSL
#include <openssl/err.h>  // Функции обработки ошибок OpenSSL

// Конфигурационные константы
const int PORT = 8443;            // Порт для прослушивания
const char* CERT_FILE = "cert.pem"; // Путь к сертификату
const char* KEY_FILE = "key.pem";   // Путь к приватному ключу

// Функция обработки ошибок
void handle_error(const char* msg) {
    perror(msg);                 // Вывод системной ошибки
    ERR_print_errors_fp(stderr); // Вывод ошибок OpenSSL
    exit(EXIT_FAILURE);          // Аварийное завершение
}

// Создание и настройка SSL контекста
SSL_CTX* create_ssl_context() {
    // 1. Создаем базовый контекст для сервера
    // TLS_server_method() автоматически выбирает максимально 
    // поддерживаемую версию TLS
    SSL_CTX* ctx = SSL_CTX_new(TLS_server_method());
    if (!ctx) handle_error("Ошибка создания SSL контекста");

    // 2. Загружаем сертификат сервера в формате PEM
    // Сертификат содержит публичный ключ и информацию о владельце
    if (SSL_CTX_use_certificate_file(ctx, CERT_FILE, SSL_FILETYPE_PEM) <= 0)
        handle_error("Ошибка загрузки сертификата");

    // 3. Загружаем приватный ключ сервера
    // Должен соответствовать публичному ключу в сертификате
    if (SSL_CTX_use_PrivateKey_file(ctx, KEY_FILE, SSL_FILETYPE_PEM) <= 0)
        handle_error("Ошибка загрузки приватного ключа");

    // 4. Проверяем соответствие ключа и сертификата
    if (!SSL_CTX_check_private_key(ctx))
        handle_error("Несоответствие ключа и сертификата");

    return ctx; // Возвращаем готовый к использованию контекст
}

int main() {
    // Инициализация OpenSSL
    SSL_library_init();          // Загрузка алгоритмов SSL/TLS
    OpenSSL_add_all_algorithms(); // Инициализация криптографических алгоритмов
    SSL_load_error_strings();    // Загрузка текстовых описаний ошибок
    
    // Создаем и настраиваем SSL контекст
    SSL_CTX* ctx = create_ssl_context();
    
    /*** Настройка TCP сервера ***/
    // 1. Создаем TCP сокет (IPv4, потоковый, протокол по умолчанию)
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd < 0) handle_error("Ошибка создания сокета");

    // 2. Настраиваем параметры сервера
    sockaddr_in server_addr{};
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);
    
    // 3. Привязываем сокет к адресу
    if (bind(server_fd, (sockaddr*)&server_addr, sizeof(server_addr)) < 0)
        handle_error("Ошибка bind");
        
    // 4. Начинаем прослушивание (очередь на 1 соединение)
    listen(server_fd, 1);
    std::cout << "Сервер слушает на порту " << PORT << "..." << std::endl;
    
    /*** Обработка входящего соединения ***/
    // 1. Принимаем входящее соединение
    sockaddr_in client_addr{};
    socklen_t client_len = sizeof(client_addr);
    int client_fd = accept(server_fd, (sockaddr*)&client_addr, &client_len);
    if (client_fd < 0) 
	    handle_error("Ошибка accept");
    
    /*** Настройка TLS соединения ***/
    // 1. Создаем новую SSL структуру для соединения
    SSL* ssl = SSL_new(ctx);
    
    // 2. Связываем SSL структуру с файловым дескриптором сокета
    SSL_set_fd(ssl, client_fd);
    
    // 3. Выполняем TLS handshake (блокирующая операция)
    // Внутри происходит:
    // - Обмен сертификатами
    // - Согласование параметров шифрования
    // - Обмен ключами
    if (SSL_accept(ssl) <= 0) 
	    handle_error("Ошибка SSL handshake");
	    
    std::cout << "Клиент подключён!" << std::endl;
    
    /*** Обмен данными ***/
    // 1. Принимаем данные от клиента
    char buf[1024];
    int bytes = SSL_read(ssl, buf, sizeof(buf) - 1);
    if (bytes > 0) {
        buf[bytes] = '\0'; // Добавляем завершающий нуль
        std::cout << "Получено: " << buf << std::endl;
    }
    
    // 2. Отправляем ответ клиенту
    const char* response = "Hello from TLS Server!";
    SSL_write(ssl, response, strlen(response));
    
    /*** Завершение работы ***/
    // 1. Корректно закрываем SSL соединение (отправляем close_notify)
    SSL_shutdown(ssl);
    // 2. Освобождаем ресурсы SSL
    SSL_free(ssl);
    // 3. Закрываем TCP соединение
    close(client_fd);
    // 4. Закрываем слушающий сокет
    close(server_fd);
    // 5. Освобождаем SSL контекст
    SSL_CTX_free(ctx);
    return 0;
}
```