### **Широковещательный шторм (Broadcast Storm) в L2-сетях**  
**Широковещательный шторм** — это ситуация в сетях уровня L2 (Ethernet, коммутаторы), когда в сети начинает бесконтрольно циркулировать огромное количество широковещательных (broadcast), multicast или даже unicast-кадров, приводя к перегрузке оборудования и полной или частичной недоступности сети.  

#### **Причины возникновения**  
1. **Петли в топологии (Loop)**  
   - Если в сети есть кольцо (например, два коммутатора соединены двумя кабелями), и не работает **STP (Spanning Tree Protocol)**, то широковещательные кадры начинают бесконечно ходить по кругу.  
   - Пример: коммутатор A отправляет broadcast → коммутатор B → коммутатор A → и так до бесконечности.  

2. **Некорректная работа STP**  
   - Если STP отключен или настроен неправильно, петли не блокируются.  
   - Ошибки в настройке приоритетов коммутаторов могут привести к неожиданным петлям.  

3. **Бесконечное зацикливание unicast-трафика (из-за ошибок в MAC-таблицах)**  
   - Если MAC-таблица коммутатора переполнена или сброшена, он может начать флудить кадры во все порты.  

4. **Вирусы и сетевые атаки**  
   - Некоторые вредоносные программы (например, старые вирусы вроде "NetSky") генерируют огромное количество broadcast-запросов (ARP, NetBIOS).  

5. **Некорректная работа сетевых протоколов**  
   - Ошибки в ARP, DHCP, IP-телефонии (например, массовые запросы).  

#### **Как это выглядит на практике?**  
- **Сеть "лагает" или полностью недоступна.**  
- **Индикаторы портов на коммутаторах горят постоянно (100% загрузка).**  
- **Коммутаторы могут зависать или перезагружаться.**  
- **Wireshark покажет огромное количество дублирующихся кадров (например, ARP-запросы).**  

### **Spanning Tree Protocol (STP) — защита L2-сетей от широковещательных штормов**  

**STP (IEEE 802.1D)** — это протокол канального уровня (L2), который предотвращает петли (loops) в Ethernet-сетях с избыточными соединениями. Его основная задача — **блокировать избыточные пути**, оставляя только один активный путь между любыми двумя устройствами, чтобы избежать широковещательных штормов.  

---

## **Почему без STP возможен широковещательный шторм?**  
В сети с коммутаторами (L2) **широковещательные кадры (broadcast)** и **неизвестные unicast-кадры** передаются **во все порты**, кроме порта-источника.  

**Пример петли:**  
```
   [Коммутатор A]  
    /        \  
[Коммутатор B]  
    \        /  
   [Коммутатор C]  
```
Если STP **выключен**, то:  
1. Коммутатор A отправляет broadcast-кадр.  
2. Коммутаторы B и C получают его и пересылают друг другу.  
3. Кадр начинает бесконечно циркулировать, **перегружая CPU коммутаторов и забивая полосу**.  

**Результат:**  
- Сеть "лагает" или полностью падает.  
- Коммутаторы перегружены из-за обработки тысяч дублирующихся кадров.  

---

## **Как STP предотвращает шторм?**  
STP **автоматически блокирует избыточные пути**, оставляя только **один активный путь** (дерево, spanning tree).  

### **Основные этапы работы STP:**  
1) Сначала выбирается так называемый **корневой мост/свич (root bridge)**. Это устройство, которое STP считает точкой отсчета, центром сети; все дерево STP сходится к нему. Выбор базируется на таком понятии, как идентификатор свича **(Bridge ID)**. Bridge ID это число длиной 8 байт, которое состоит из Bridge Priority (приоритет, от 0 до 65535, по умолчанию 32768+номер vlan или инстанс MSTP, в зависимости от реализации протокола), и MAC-адреса устройства. В начале выборов каждый коммутатор считает себя корневым, о чем и заявляет всем остальным с помощью BPDU(специальный тип пакетов, которыми обмениваются свичи), в котором представляет свой идентификатор как ID корневого свича. При этом, если он получает BPDU с меньшим Bridge ID, он перестает хвастаться своим и покорно начинает анонсировать полученный Bridge ID в качестве корневого. В итоге, корневым оказывается тот свич, чей Bridge ID меньше всех.

2) После того, как коммутаторы померились айдями и выбрали root bridge, каждый из остальных свичей должен найти один, и только один порт, который будет вести к корневому свичу. Такой порт называется **корневым портом (Root port)**. Чтобы понять, какой порт лучше использовать, каждый некорневой свич определяет стоимость маршрута от каждого своего порта до корневого свича. Эта стоимость определяется суммой стоимостей всех линков, которые нужно пройти кадру, чтобы дойти до корневого свича. В свою очередь, стоимость линка определяется просто- по его скорости (чем выше скорость, тем меньше стоимость). Процесс определения стоимости маршрута связан с полем BPDU “Root Path Cost” и происходит так: Корневой свич посылает BPDU с полем Root Path Cost, равным нулю. Ближайший свич смотрит на скорость своего порта, куда BPDU пришел, и добавляет стоимость в таблицу стоимости. Далее этот второй свич посылает этот BPDU нижестоящим коммутаторам, но уже с новым значением Root Path Cost, и далее по цепочке вниз. Если имеют место одинаковые стоимости — корневым выбирается меньший порт.

3) Далее выбираются **назначенные** (**Designated**) порты. Из каждого конкретного сегмента сети должен существовать только один путь по направлению к корневому свичу, иначе это петля. В данном случае имеем в виду физический сегмент, в современных сетях без хабов это, грубо говоря, просто провод. Назначенным портом выбирается тот, который имеет лучшую стоимость в данном сегменте. У корневого свича все порты — назначенные.

**И вот уже после того, как выбраны корневые и назначенные порты, оставшиеся блокируются, таким образом разрывая петлю.**


## **Состояния портов**

Чуть раньше мы упомянули состояние блокировки порта, теперь поговорим о том, что это значит, и о других возможных состояниях порта в STP. Итак, в обычном (802.1D) STP существует 5 различных состояний:

- **Блокировка** (**blocking**): блокированный порт не шлет ничего. Это состояние предназначено, как говорилось выше, для предотвращения петель в сети. Блокированный порт, тем не менее, слушает BPDU (чтобы быть в курсе событий, это позволяет ему, когда надо, разблокироваться и начать работать)

- **Прослушивание** (**listening**): порт слушает и начинает сам отправлять BPDU, кадры с данными не отправляет.

- **Обучение** (**learning**): порт слушает и отправляет BPDU, а также вносит изменения в CAM- таблицу, но данные не перенаправляет.

- **Пересылка** (**forwarding**): этот может все: и посылает\принимает BPDU, и с данными оперирует, и участвует в поддержании таблицы mac-адресов. То есть это обычное состояние рабочего порта.

- **Отключен** (**disabled**): состояние administratively down, отключен командой **shutdown**. Понятное дело, ничего делать не может вообще, пока вручную не включат.

Порядок перечисления состояний не случаен: при включении (а также при втыкании нового провода), все порты на устройстве с STP проходят вышеприведенные состояния именно в таком порядке (за исключением disabled-портов).

Возникает закономерный вопрос: а зачем такие сложности? А просто STP осторожничает. Ведь на другом конце провода, который только что воткнули в порт, может быть свич, а это потенциальная петля. Вот поэтому порт сначала 15 секунд (по умолчанию) пребывает в состоянии прослушивания — он смотрит BPDU, попадающие в него, выясняет свое положение в сети — как бы чего не вышло, потом переходит к обучению еще на 15 секунд — пытается выяснить, какие mac-адреса “в ходу” на линке, и потом, убедившись, что ничего он не поломает, начинает уже свою работу.

Итого, мы имеем целых 30 секунд простоя, прежде чем подключенное устройство сможет обмениваться информацией со своими соседями.

Современные компы грузятся быстрее, чем за 30 секунд. Вот комп загрузился, уже рвется в сеть, истерит на тему “DHCP-сервер, сволочь, ты будешь айпишник выдавать, или нет?”, и, не получив искомого, обижается и уходит в себя, извлекая из своих недр айпишник [автонастройки.](https://ru.wikipedia.org/wiki/APIPA) Естественно, после таких экзерсисов, в сети его слушать никто не будет, ибо “не местный” со своим 169.254.x.x. Понятно, что все это не дело, но как этого избежать?

#### Portfast

Для таких случаев используется особый режим порта — portfast. При подключении устройства к такому порту, он, минуя промежуточные стадии, сразу переходит к forwarding-состоянию. Само собой, portfast следует включать только на интерфейсах, ведущих к конечным устройствам (рабочим станциям, серверам, телефонам и т.д.), но не к другим свичам.

---

## **3. Пример работы STP**  
**Топология:**  
```
       [Root Bridge: Switch 1]  
         (Priority: 0, MAC: 00:11:22)  
           /               \  
[Switch 2]------------------[Switch 3]  
```  

1. **Выбор Root Bridge:**  
   - Switch 1 имеет наименьший Bridge ID → становится корневым.  

2. **Выбор Root Ports:**  
   - У Switch 2 и Switch 3 **корневой порт** — тот, что ведет к Switch 1.  

3. **Выбор Designated Ports:**  
   - На линке между Switch 2 и Switch 3 один порт должен быть **Designated**, а второй — **Blocked**.  
   - Выбирается порт с **лучшим путем к Root Bridge**.  

4. **Итог:**  
   - Только **один путь** между любыми двумя узлами активен.  
   - Широковещательные кадры **не зацикливаются**.  

---

## **4. Улучшенные версии STP**  
- **RSTP (Rapid STP, IEEE 802.1w)** – быстрая конвергенция (секунды вместо 30-50 сек).  
- **MSTP (Multiple STP, IEEE 802.1s)** – поддержка нескольких VLAN.  
- **PVST+ (Per-VLAN STP, Cisco)** – отдельное дерево для каждого VLAN.  
